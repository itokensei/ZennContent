---
title: "型は命題：Scala 3で「数学的帰納法」を表現してみた"
emoji: ""
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
# はじめに
多くのプログラマにとって型は変数の情報を教えてくれるもの、バグを検知してくれるものという認識かと思いますが、ちょっと違う角度から見てみます。都合上、例としてScala(たまにScala 3)の構文を扱います。

# 型は命題、値は証明
型`A`の値を引数にとり、型`B`の値を返す関数`f`は関数型`A => B`です[^1]。
[^1]:ここでいう関数はScalaの関数オブジェクトではなくメソッドです。

```scala
val f: A => B = (x: A) => {
  ...
  b
}
```

ここで、型`A`を**命題**`A`と言い換えてみましょう。「命題」とは真偽の定まる主張のことです。
具体的には $0 < 1$ や $2 < 1$ （前者は真、後者は偽）です。少し用法が違いますが「定理」の方が聞き馴染みがあるかもしれません。定理には「証明」が必要です。さらに`A`の値`a`を**証明**`a`と言い換えてみましょう。

このとき、「関数`f`は命題`A`の証明を受け取って、命題`B`の証明を返すもの」と言えます。つまり`f`は命題`A`が証明できるならば命題`B`が証明できることを示す証明です。論理の世界では「`A`ならば`B`」という命題が証明されたことになります。論理記号では

$$
A \Longrightarrow B
$$
と表されたりします。記法も似ていますね。

このようにプログラムにおける関数は論理における「ならば」と対応しています。

本記事のゴールはこの対応を用いて、**数学的帰納法の主張を型で表現**するところまでにしましょう。

# 他の対応
前節のようなプログラムと論理の対応は他にもあります。例えば、**ペア型**（あるいはタプル型）は論理における「**かつ**」と対応しています。

```scala
// 前提
a: A
b: B
---
// 帰結
(a, b): (A, B)
```
考え方は同じです。命題`A`の証明と命題`B`の証明が得られれば、命題「`A`かつ`B`」の証明が得られます。逆に`A`かつ`B`の証明が得られれば、`A, B`それぞれの証明が得られます。関数としてもペア型の関数

```scala
p: (A, B)
---
p._1: A

p: (A, B)
---
p._2: B
```

では論理における「または」に対応するものは何でしょうか？Scalaでいえば、プリミティブではありませんが`Either`でしょうか。

```scala
a: A
---
Left(a): Either[A, B]

b: B
---
Right(b): Either[A, B]
```

命題`A`か命題`B`の証明が得られれば、命題「`A`または`B`」の証明が得られます。

:::message
Scala 3やTypeScriptには交差型`A & B`やユニオン型`A | B`があります。記法的にも意味的にも「かつ」や「または」と関連しますが、部分型の側面が強いので別の対応[^1]を考えることが望ましいと思いました。
[^1]: PADAoneさんの記事: https://zenn.dev/estra/books/algebraic-subtyping-models/viewer/7-2-ast-lattice-theoretic-model-2
:::

否定に入る前に、論理における**矛盾**を考えます。これはScalaの`Nothing`に対応します。`Nothing`は例外やエラーを投げる場合に登場する、値のない型です。あるはずのない証明が得られれば、それは矛盾します。記号として`Con`と表すことにします。そして命題`A`の否定は

$$
A\Longrightarrow Con
$$

と言い換えられます。命題`A`とあわせて証明されれば、直ちに矛盾するからです。よって否定はプログラムにおいて関数`A => Nothing`に対応します。

以上をまとめておきます。
| プログラム | 論理 |
| ---- | ---- |
| 関数型 | ならば |
| ペア型 | かつ |
| Either型 | または |
| Nothing | 矛盾 |

:::message
否定の扱いがやや特殊に思えますが、正確な対応はプログラムの型付き計算モデルと少し特徴のある論理にあります。（**Curry-Howard対応**）
:::
## 三段論法
前節で命題`A`とその否定`A => Con`から矛盾`Con`を導きました。これは**モーダスポネンス*と呼ばれるものです。

$$
(A, A => B) => B
$$

です。前節に従って、命題を型で表現しています。その証明はまさしく**関数適用**そのものです。

```scala
a: A
f: A => B
---
f(a): B
```
**カリー化**した方が見覚えのある方もいるかもしれませんね。

```scala
apply: A => (A => B) => B
```

# 数学的帰納法の形式化
論理には**述語**という概念があります。例えば自然数（0を含む整数）上の述語`P`とは自然数`n`を定めると命題`P(n)`が定まるものです。具体的には自然数$n$について$n > 0$は自然数上の述語です。

そして、自然数上の述語Pに対し**数学的帰納法**という主張があります。
`P(0)`が証明できて、「すべての自然数`n`について、`P(n)`ならば`P(n + 1)`」が証明できたとする。このとき、「すべての`n`について`P(n)`」が証明できると主張するものです。

数学的帰納法を型で表現するには、以下が表現できなければいけません

1. 自然数`Nat`
2. 述語`P`
3. すべての`n`について`P(n)`

これらをScala 3の構文でやってみます。

## 自然数とその述語
自然数`Nat`は再帰的列挙型を用いて表現できます

```scala
enum Nat:
  case Zero
  case Succ(n: Nat)
```

しかし、述語に困りました。より表現能力の高い型システムであれば型を値にもつ**型ユニバース**`U`を用いて単純な関数型`P: Nat -> U`に落とし込めるのですが、Scala 3には型ユニバースがありません。

そこで`Nat`を工夫することにします。
```scala
enum Nat:
  type Value
  case Zero extends Nat:
    type Value = Unit
  case Succ(n: Nat) extends Nat:
    type Value = Option[n.Value]

trait P[+T]
```
これにより、値`n: N`ごとに型`n.Value`を割り当てることで、述語`P`を型パラメータをもつトレイトとして定義できます。

「すべての`n`について`P[n.Value]`」を直接的に証明するためには`n`ごとに`P[n.Value]`の証明`f(n)`があれば良いはずです。`f(n): P[n.Value]`と表記すると奇妙に映るかもしれません。関数の返り値型が引数の値に依存して変わりうることを示していますよね。これを**依存関数型（Dependent types）
**といいます。

```scala
f: (n: N) => P[n.Value]
```

以上を組み合わせると、数学的帰納法は次のように型で表現できます。

```Scala
P[Zero.Value] => ((n: N) => (P[n.Value] => P[Succ(n).Value]))=> (n: N) => P[n.Value]
```

# おわりに
命題を型で表現することの感覚だけつかんでもらえたら嬉しいのですが、実際には命題を証明するところにうまみがあります。数学的帰納法を用いて、具体的な述語の実装に対して`(n: N) => P[n.Value]`をどう証明するか、数学的帰納法自体の証明はどうであるか。今回のコードでは、考慮できてないところがまだありますね。

今回のような話は形式検証という領域で、数学的帰納法にのみフォーカスしました。一方でプログラムに関する性質を証明することにも使われており、Cコンパイラの正しさ[^2]の検証などに応用例が挙げられます。興味のある方は調べてみてください。
[^2]: CompCert: https://www.absint.com/compcert/index_ja.htm
