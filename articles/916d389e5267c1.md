---
title: "型は命題：Scala 3で「数学的帰納法」を表現してみた"
emoji: ""
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["型", "論理", "関数型言語", "Scala", "Scala 3"]
published: false
publication_name: "nextbeat"
---
# はじめに
多くのプログラマにとって型は変数の情報を教えてくれるもの、バグを検知してくれるものという認識かと思いますが、ちょっと違う角度から見てみます。都合上、例としてScala（たまにScala 3）の構文を扱います。

# 型は命題、値は証明
プログラムの世界と論理の世界にはある種の対応関係が存在します。それは
```scala
値: 型
```
を
```scala
証明: 命題
```
とみなすものです。ここで「 **命題** 」とは真偽の定まる主張のことで、具体的には`0 < 1`や`2 < 1`（前者は真、後者は偽）です。命題が真であることを示すための手続きが「 **証明** 」です。

この対応は **Curry-Howard対応** とよばれるものです。本記事のゴールは、この対応を用いて **数学的帰納法の主張を型で表現** することとします。

以下、対応について順番に説明します。

## 対応: 関数型と「ならば」
型`A`の値を引数にとり、型`B`の値を返す関数`f`の型は関数型`A => B`です。

```scala
val f: A => B = (a: A) => {
  ...
  b
}
```

ここで、型`A`を命題`A`、`A`の値`a`を証明`a`と言い換えてみると、「関数`f`は命題`A`の証明を受け取って、命題`B`の証明を返すもの」と言えます。つまり`f`は命題`A`が証明できるならば命題`B`が証明できることを示す証明です。論理の世界では「`A`ならば`B`」という命題が証明されたことになります。論理記号では

$$
A \Longrightarrow B
$$
と表されたりします。記法も似ていますね。

このようにプログラムにおける関数は論理における「 **ならば** 」と対応しています。

## 他の対応
前節のようなプログラムと論理の対応は他にもあります。例えば、 **ペア型** （あるいはタプル型）は論理における「 **かつ** 」と対応しています。

```scala
// 前提
a: A
b: B
---
// 帰結
(a, b): (A, B)
```
考え方は同じです。命題`A`の証明と命題`B`の証明が得られれば、命題「`A`かつ`B`」の証明が得られます。逆に`A`かつ`B`の証明が得られれば、`A, B`それぞれの証明が得られます。これはペアの第１要素、第２要素を取る関数に対応しています。

```scala
p: (A, B)
---
p._1: A

p: (A, B)
---
p._2: B
```

では、論理における「 **または** 」に対応するものは何でしょうか？Scalaでいえば、プリミティブではありませんが`Either`でしょうか。

```scala
a: A
---
Left(a): Either[A, B]

b: B
---
Right(b): Either[A, B]
```

命題`A`か命題`B`の証明が得られれば、命題「`A`または`B`」の証明が得られます。

:::message
Scala 3やTypeScriptには交差型`A & B`やユニオン型`A | B`があります。記法的にも意味的にも「かつ」や「または」と関連しますが、部分型の側面が強いので別の対応[^1]を考えることが望ましいと思いました。
[^1]: PADAoneさんの記事: https://zenn.dev/estra/books/algebraic-subtyping-models/viewer/7-2-ast-lattice-theoretic-model-2
:::

否定に入る前に、論理における **矛盾** を考えます。これはScalaの`Nothing`に対応します。`Nothing`は例外やエラーを投げる場合に登場する、値のない型です。あるはずのない証明が得られれば、それは矛盾します。矛盾（contradiction）を`Con`と表すことにすると、命題`A`の否定は

$$
A\Longrightarrow Con
$$

と言い換えられます。命題`A`と命題`A => Con`が証明されれば、直ちに矛盾し、`Con`が導かれます。よって、否定はプログラムにおいて関数`A => Nothing`に対応します。

以上をまとめておきます。
| プログラム | 論理 |
| ---- | ---- |
| 関数型 | ならば |
| ペア型 | かつ |
| Either型 | または |
| Nothing | 矛盾 |

:::message
否定の扱いが特殊に思えますが、Curry-Howard対応において対象となる論理は「 **直観主義論理** 」というやや特殊なものになります。
:::

## 関数適用とモーダスポネンス
前節で命題`A`とその否定`A => Con`から矛盾`Con`を導きました。これは **モーダスポネンス** と呼ばれるものです。

$$
(A, A\Longrightarrow B)\Longrightarrow B
$$

です。前節に従って、命題を型で表現しています。その証明はまさしく **関数適用** そのものです。

```scala
a: A
f: A => B
---
f(a): B
```
 **カリー化** した方が見覚えのある方もいるかもしれませんね。

```scala
apply: A => (A => B) => B
```

この形が次節で登場します。

# 数学的帰納法の形式化
論理には**述語**という概念があります。例えば、自然数（0を含む正の整数）上の述語`P`とは、自然数`n`を定めると命題`P(n)`が定まるものです。具体的には自然数`n`について、`n > 0`は自然数上の述語です。

そして、自然数上の述語Pに対し **数学的帰納法** という主張があります。数学的帰納法とは、以下を主張するものです。
> `P(0)`が証明できて、「すべての自然数`n`について、`P(n)ならばP(n + 1)`」が証明できたとする。このとき、「すべての`n`について`P(n)`」が証明できる。

`P(0)`を**基底ケース**、「すべての自然数`n`について、`P(n)ならばP(n + 1)`」を **帰納ステップ** といいます。

数学的帰納法を型で表現するには、以下を型として表現できなければいけません。

1. 自然数`Nat`
2. 述語`P`
3. すべての`n`について`P(n)`

これらをScala 3の構文でやってみます。

## 自然数とその述語
自然数`Nat`は再帰的列挙型を用いて表現できます

```scala
enum Nat:
  case Zero
  case Succ(n: Nat)
```

しかし、述語に困りました。より表現能力の高い型システムであれば型を値にもつ **型ユニバース** `U`を用いて単純な関数型`P: Nat -> U`に落とし込めるのですが、Scala 3には型ユニバースがありません。

そこで、値`n: Nat`ごとに型`n.Value`を割り当てることにします。
```scala
enum Nat:
  type Value
  case Zero extends Nat:
    type Value = Unit
  case Succ(n: Nat) extends Nat:
    type Value = Option[n.Value]

trait P[+T]
```
これにより、型パラメータをもつトレイト`P`は`n: Nat`に対し型`P[n.Value]`を定めます。

## 依存関数型
「すべての`n`について`P[n.Value]`」を直接的に証明するためには`n`ごとに`P[n.Value]`の証明`f(n)`があれば良いはずです。`f(n): P[n.Value]`と表記すると奇妙に映るかもしれません。関数の返り値型が引数の値に依存して変わりうることを示していますね。これを **依存関数型（Dependent function types）** といいます。

```scala
f: (n: Nat) => P[n.Value]
```

以上を組み合わせると、数学的帰納法は次のように型で表現できます。

```Scala
P[Zero.Value] => ((n: Nat) => (P[n.Value] => P[Succ(n).Value]))
=> (n: Nat) => P[n.Value]
```

主張の全体は関数適用と同じ形になっています。`P[Zero.Value]`が基底ケース、`(n: Nat) => (P[n.Value] => P[Succ(n).Value])`が帰納ステップに対応し、残る`(n: Nat) => P[n.Value]`が数学的帰納法を用いて得られる結論に対応します。

# おわりに
命題を型で表現することの感覚だけでもつかんでもらえたら嬉しいのですが、実際には命題を証明するところにうまみがあります。数学的帰納法を用いて、具体的な述語の実装に対して`(n: Nat) => P[n.Value]`をどう証明するか、数学的帰納法自体の証明はどうであるか。今回のコードでは、考慮できてないところがまだありますね。

今回のような話は形式検証という領域で扱われますが、本記事では数学的帰納法にのみフォーカスしました。一方でプログラムに関する性質を証明することにも使われており、Cコンパイラの正しさ[^2]の検証などに応用例が挙げられます。興味のある方は調べてみてください。
[^2]: CompCert: https://www.absint.com/compcert/index_ja.htm
